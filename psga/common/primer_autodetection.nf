/*
 * Run: primer-autodetection (use first read only for illumina)
 */
process primer_autodetection {
  publishDir "${params.output_path}/primer_autodetection", mode: 'copy', overwrite: true, pattern: '{*_primer_data.csv,*_primer_detection.csv}'

  tag "${task.index} - ${fastq}"

  input:
    path fastq
    val pathogen

  output:
    tuple path("*_primer.txt"), path(fastq), emit: ch_files
    path "*_primer_data.csv", emit: ch_primer_data
    path "*_primer_detection.csv", emit: ch_primer_coverage

  shell:
  '''
  # select the input fastq file based on illumina or ont.
  # For illumina, 1 read is sufficient for primer autodetection
  if [[ "!{params.sequencing_technology}" == "illumina" ]]; then
    file_1="$(ls *_1.fastq.gz)"
  elif [[ "!{params.sequencing_technology}" == "ont" ]]; then
    file_1="!{fastq}"
  else
    echo "sequencing technology must be either 'illumina' or 'ont' for primer autodetection"
    exit 1
  fi

  # extract the sample id, whereas this is ID.fastq.gz or ID_1.fastq.gz
  sample_id=$( echo ${file_1} | cut -d '.' -f1 | cut -d '_' -f1)
  trimmed_sample="trimmed_sample.fastq.gz"
  crop="!{params.primer_minimum_length}"
  pathogen="!{pathogen}"

  # trim sample reads so that they are long as the shortest primer
  trimmomatic SE -phred33 ${file_1} ${trimmed_sample} CROP:${crop} 2> trimmomatic.out

  # iterate over the available primer scheme fasta.
  # These fasta are generated by us and contain the sequences for each primer scheme name/version
  readarray -t primer_fasta_array < "/primer_schemes/${pathogen}_primer_fasta_index.txt"
  for primer_fasta_record in "${primer_fasta_array[@]}"; do
      # extract fasta file and number of primers
      primer_fasta="$(echo "${primer_fasta_record}" | cut -d',' -f1)"
      total_num_primers="$(echo "${primer_fasta_record}" | cut -d',' -f2)"

      # extract the primer (e.g. ARTIC_V3)
      primer="$(echo "${primer_fasta}" | cut -d/ -f3,5 | sed 's#/#_#')"

      echo -e "@SQ\tSN:${primer}\tLN:${crop}" > ${primer}.header

      # build the index for the primer fasta
      bowtie2-build ${primer_fasta} ${primer}.ref_idx &> ${primer}.bowtie2-build

      # end-to-end alignment of the trimmed sample against the primer scheme fasta
      # force bowtie2 to align adjacent sub-sequences long exactly ${crop} (-D 0 -R 0 -L 20) and be stringent (-N 0 --score-min C,-1):
      # --score-min C,-1 means that the minimum acceptable score is -1. In end-to-end, 0 is the highest score and -1 is given when
      # 1 single "N" is found in the sample read. This corresponds to a maximum of 1/20=0.05 => 5% uncertainty that the selected primer match is incorrect.
      # The sample/primer bam file is then reheadered so that the reference sequence name is the same
      # Notes:
      # 1) due to Groovy, + in sed needs double backslash
      # 2) samtools sort fails if the input sam is malformed
      bowtie2 --no-unal -D 0 -R 0 -N 0 -L 20 --score-min C,-1 -x ${primer}.ref_idx -U trimmed_sample.fastq.gz | samtools view | sed 's/_cropped_primer_seq_[0-9]\\+//g' | cat ${primer}.header - | samtools sort -o ${primer}.bam

      # extract metrics
      primer_numreads="$(samtools view -c ${primer}.bam)"
      primer_unique_numreads="$(samtools view ${primer}.bam | cut -f 10 | sort | uniq | wc -l)"

      echo "primer_detected,total_num_primers,primer_numreads,primer_unique_numreads" > ${primer}.coverage.csv
      echo "${primer},${total_num_primers},${primer_numreads},${primer_unique_numreads}" >> ${primer}.coverage.csv

  done

  python ${PSGA_ROOT_PATH}/scripts/common/primer_autodetection.py --input-path . --sample-id "${sample_id}" --primer-input !{params.kit}
  '''
}
